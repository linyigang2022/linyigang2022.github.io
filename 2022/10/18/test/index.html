<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>test | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Docker  Docker概述 Docker安装 Docker命令 镜像命令 容器命令 操作命令 …   Docker镜像 容器数据卷 DockerFile Docker网络原理 IDEA整合Docker Docker Compose Docker Swarm CI\CD jenkins  一、Docker概述1. Docker为什么出现？ 一个产品需要应用环境（需要开发-上线两套环境；），应用">
<meta property="og:type" content="article">
<meta property="og:title" content="test">
<meta property="og:url" content="http://example.com/2022/10/18/test/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Docker  Docker概述 Docker安装 Docker命令 镜像命令 容器命令 操作命令 …   Docker镜像 容器数据卷 DockerFile Docker网络原理 IDEA整合Docker Docker Compose Docker Swarm CI\CD jenkins  一、Docker概述1. Docker为什么出现？ 一个产品需要应用环境（需要开发-上线两套环境；），应用">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="d:/Typora/myMarkDown/images/image-20210522094055783.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191018161530148.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019101816185929.png">
<meta property="og:image" content="d:/Typora/myMarkDown/images/image-20210523083932646.png">
<meta property="og:image" content="https://pic2.zhimg.com/50/v2-34d2eacdb8c2abb84254b30b7cb5b1e0_hd.jpg?source=1940ef5c">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1865616/202004/1865616-20200420232419387-1082587992.jpg">
<meta property="og:image" content="d:/Typora/myMarkDown/images/image-20210522225031016.png">
<meta property="og:image" content="d:/Typora/myMarkDown/images/image-20210523082512834.png">
<meta property="og:image" content="d:/Typora/myMarkDown/images/image-20210523151709602.png">
<meta property="og:image" content="d:/Typora/myMarkDown/images/image-20210523155014858.png">
<meta property="og:image" content="d:/Typora/myMarkDown/images/image-20210523160107736.png">
<meta property="og:image" content="d:/Typora/myMarkDown/images/image-20210523185118484.png">
<meta property="og:image" content="d:/Typora/myMarkDown/images/image-20210523185611492.png">
<meta property="og:image" content="d:/Typora/myMarkDown/images/image-20210523203413961.png">
<meta property="og:image" content="d:/Typora/myMarkDown/images/image-20210523230854806.png">
<meta property="og:image" content="d:/Typora/myMarkDown/images/image-20210524112718882.png">
<meta property="og:image" content="d:/Typora/myMarkDown/images/image-20210524153507082.png">
<meta property="og:image" content="d:/Typora/myMarkDown/images/image-20210524155157138.png">
<meta property="article:published_time" content="2022-10-18T07:14:31.000Z">
<meta property="article:modified_time" content="2022-10-18T07:15:47.800Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/Typora/myMarkDown/images/image-20210522094055783.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-test" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/18/test/" class="article-date">
  <time datetime="2022-10-18T07:14:31.000Z" itemprop="datePublished">2022-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      test
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Docker</strong></p>
<ul>
<li>Docker概述</li>
<li>Docker安装</li>
<li>Docker命令<ul>
<li>镜像命令</li>
<li>容器命令</li>
<li>操作命令</li>
<li>…</li>
</ul>
</li>
<li>Docker镜像</li>
<li>容器数据卷</li>
<li>DockerFile</li>
<li>Docker网络原理</li>
<li>IDEA整合Docker</li>
<li>Docker Compose</li>
<li>Docker Swarm</li>
<li>CI\CD jenkins</li>
</ul>
<h1 id="一、Docker概述"><a href="#一、Docker概述" class="headerlink" title="一、Docker概述"></a>一、Docker概述</h1><h2 id="1-Docker为什么出现？"><a href="#1-Docker为什么出现？" class="headerlink" title="1. Docker为什么出现？"></a>1. Docker为什么出现？</h2><ol>
<li><p>一个产品需要应用环境（需要开发-上线两套环境；），应用配置</p>
</li>
<li><p>开发–运维问题：（1）我的电脑可以运行（2）版本更新，导致服务不可用；对于运维来说，考验非常大</p>
</li>
<li><p>环境配置十分麻烦，每一个机器都要部署环境（集群Redis，ES，Hadoop…），费时费力</p>
</li>
<li><p>发布一个项目（jar + [Redis MySQL JDK ES]），<strong>项目能不能带上环境安装打包</strong>？</p>
<p>之前在服务器配置一个应用的环境Redis MySQL JDK ES Hadoop，配置很麻烦，不能跨平台（比如windows开发，最后发布到Linux）</p>
<p><strong>传统</strong>：jar + 运维来做部署</p>
<p><strong>现在</strong>：开发打包部署上线，一套流程作为</p>
<p>Docker给以上问题，提出了解决方案</p>
<p><strong>类比app的开发</strong>：java – apk – 发布（应用商店）– 张三使用apk – 安装即可</p>
<p><strong>现在java开发</strong>：java – jar（带环境）打包项目带上环境（镜像）– （Docker仓库：商店）– 下载我们发布的镜像 – 直接运行即可</p>
</li>
</ol>
<img src="D:\Typora\myMarkDown\images\image-20210522094055783.png" alt="image-20210522094055783" style="zoom:67%;float:left" />

<p>Docker的思想来源于集装箱<br>传统：JRE – 多个应用（端口冲突）– 原来都是交叉的<br>现在：隔离：Docker核心思想！打包装箱，每个箱子都是互相隔离的。</p>
<h2 id="2-Docker的优点"><a href="#2-Docker的优点" class="headerlink" title="2. Docker的优点"></a>2. Docker的优点</h2><p><strong>Docker为什么这么火？十分轻巧！</strong><br>在容器技术出来之前，都是使用虚拟机技术<br>虚拟机：在windows中安装Vmware，通过这个软件可以虚拟出一台或多台电脑，但是<strong>笨重</strong><br><strong>虚拟机也是属于虚拟化技术，Docker容器技术也是一种虚拟化技术。</strong></p>
<p><code>vm：需要原生镜像，模拟一台电脑出来，几个G，几分钟启动 docker：镜像：只需要最核心的环境4m，几个M，秒级启动</code></p>
<p><strong>虚拟机技术:</strong></p>
<ol>
<li><p>资源占用十分多</p>
</li>
<li><p>冗余步骤多</p>
</li>
<li><p>启动慢</p>
<img src="https://img-blog.csdnimg.cn/20191018161530148.png" alt="img" style="zoom:50%;float:left" /></li>
</ol>
<p><strong>容器化技术：</strong></p>
<ol>
<li><p>不是模拟一个完整的操作系统（只是核心）</p>
</li>
<li><p>每个应用相互隔离</p>
<img src="https://img-blog.csdnimg.cn/2019101816185929.png" alt="img" style="zoom:50%;float:left" /></li>
</ol>
<p><strong>比较Docker和虚拟机技术的不同</strong></p>
<ul>
<li>传统虚拟机，虚拟出一套硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</li>
<li>容器的应用直接应用在宿主机中，也没有虚拟自己的硬件，所以轻便</li>
<li>每个容器互相隔离，每个容器内部都有属于自己的文件系统，互不影响</li>
</ul>
<p><strong>Docker为什么比VM快</strong></p>
<ol>
<li><p>Docker有着比虚拟机更少的抽象层</p>
</li>
<li><p>Docker利用的是主机的内核，vm需要Guest OS，所以，新建容器的时候，docker不需要像vm虚拟机一样重新加载一个操作系统内核，而虚拟机需要加载Guest OS，分钟级别的，而docker利用宿主机的操作系统，省略了这个复杂的过程，秒级</p>
<img src="D:\Typora\myMarkDown\images\image-20210523083932646.png" alt="image-20210523083932646" style="zoom:50%;float:left" /></li>
</ol>
<p>Docker是<strong>基于Go语言开发</strong>的，是一个<strong>开源</strong>项目<br><strong>官网</strong>：<a target="_blank" rel="noopener" href="https://www.docker.com/">Empowering App Development for Developers | Docker</a><br><strong>文档</strong>：<a target="_blank" rel="noopener" href="https://www.docker.com/">Empowering App Development for Developers | Docker</a>Docker的文档非常详细</p>
<h2 id="3-DevOps与Docker"><a href="#3-DevOps与Docker" class="headerlink" title="3. DevOps与Docker"></a>3. DevOps与Docker</h2><blockquote>
<p>DevOps（开发、运维）Development和Operations；<br>DevOps就是让开发人员和运维人员更好地沟通合作，通过自动化流程来使得软件整体过程更加快捷和可靠。</p>
<p><img src="https://pic2.zhimg.com/50/v2-34d2eacdb8c2abb84254b30b7cb5b1e0_hd.jpg?source=1940ef5c" alt="img"></p>
</blockquote>
<ol>
<li><p><strong>应用更快速的交付和部署</strong><br>传统：一堆帮助文档，安装程序<br>Docker：打包镜像发布测试，一键运行</p>
</li>
<li><p><strong>更便捷的升级和扩缩容</strong><br>使用了Docker之后，我们部署应用和搭积木一样<br>例如当项目原本只有服务器A，需要扩展，只需要把项目打包的镜像安装到服务器B即可</p>
</li>
<li><p><strong>更简单的系统运维</strong><br>在容器化之后，我们的开发和测试环境是高度一致的</p>
</li>
<li><p><strong>更高效的计算资源利用</strong><br>Docker是内核级别的虚拟化，可以在一个物理机上运行很多个容器实例，服务器的性能可以被压榨到极致</p>
</li>
</ol>
<h1 id="二、Docker安装"><a href="#二、Docker安装" class="headerlink" title="二、Docker安装"></a>二、Docker安装</h1><h2 id="2-1-Docker的基本组成"><a href="#2-1-Docker的基本组成" class="headerlink" title="2.1 Docker的基本组成"></a>2.1 Docker的基本组成</h2><img src="https://img2020.cnblogs.com/blog/1865616/202004/1865616-20200420232419387-1082587992.jpg" alt="img" style="zoom:50%;" />

<h3 id="1-镜像（image）"><a href="#1-镜像（image）" class="headerlink" title="1. 镜像（image）"></a>1. 镜像（image）</h3><p>docker镜像就好比一个模板，可以通过这个模板来创建容器服务<br><strong>tomcat镜像 ==&gt; run ==&gt; tomcat1容器（提供服务器）</strong><br>通过这个镜像可以创建多个容器（<strong>最终服务运行或者项目运行就是在容器中的</strong>）</p>
<h3 id="2-容器（container）"><a href="#2-容器（container）" class="headerlink" title="2.容器（container）"></a>2.容器（container）</h3><p>Docker利用容器技术，独立运行一个或者一组应用，是通过镜像来创建的<br>容器可以启动、停止、删除</p>
<h3 id="3-仓库（repository）"><a href="#3-仓库（repository）" class="headerlink" title="3.仓库（repository）"></a>3.仓库（repository）</h3><p>仓库就是存放镜像的地方<br>仓库分为公有仓库和私有仓库<br>Docker Hub（默认是国外的，需要配置镜像加速）</p>
<h2 id="2-2-安装Docker"><a href="#2-2-安装Docker" class="headerlink" title="2.2 安装Docker"></a>2.2 安装Docker</h2><p>官网：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/centos/">Install Docker Engine on CentOS | Docker Documentation</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 卸载旧版本</span></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 需要的安装包</span></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 配置镜像的仓库</span></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    # https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">    # 这个仓库改为阿里云docker镜像---&gt;</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新软件包索引</span></span><br><span class="line">yum makecache fast</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 安装docker（可指定版本） docker-ce 社区版 ee 企业版</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5. 启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6. 使用docker version查看是否安装成功</span></span><br><span class="line">docker version</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7. 运行hello-world</span></span><br><span class="line">docker run hello-world</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">8. 查看拉取的hello-world镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">了解：卸载docker</span></span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line">sudo rm -rf /var/lib/docker # 删除目录，这是docker的默认工作路径</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>

<img src="D:\Typora\myMarkDown\images\image-20210522225031016.png" alt="image-20210522225031016" style="zoom: 33%;float:left;" />

<h2 id="2-3-阿里云镜像加速"><a href="#2-3-阿里云镜像加速" class="headerlink" title="2.3 阿里云镜像加速"></a>2.3 阿里云镜像加速</h2><ol>
<li><p>进入阿里云-选择产品与服务-找到容器镜像服务</p>
</li>
<li><p>点击镜像工具-镜像加速器，根据命令配置centos镜像加速器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://af49pjfn.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-4-回顾hello-world"><a href="#2-4-回顾hello-world" class="headerlink" title="2.4 回顾hello world"></a>2.4 回顾hello world</h2><h3 id="run的运行流程图"><a href="#run的运行流程图" class="headerlink" title="run的运行流程图"></a>run的运行流程图</h3><img src="D:\Typora\myMarkDown\images\image-20210523082512834.png" alt="image-20210523082512834" style="zoom: 50%;float:left" />

<h3 id="Docker底层原理"><a href="#Docker底层原理" class="headerlink" title="Docker底层原理"></a>Docker底层原理</h3><p>Docker是怎么工作的？</p>
<p>Docker是一个Client-Server的系统，Docker的守护进程运行在主机上，通过Socker从客户端访问<br>Docker-Server接收到Docker-Client的命令，就会执行这个命令</p>
<h1 id="三、Docker-命令"><a href="#三、Docker-命令" class="headerlink" title="三、Docker 命令"></a>三、Docker 命令</h1><p><strong>帮助命令</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version 	  	 # 显示docker的版本信息</span><br><span class="line">docker info		  	 # 显示更加详细的信息</span><br><span class="line">docker 命令 --help	# 万能命令</span><br></pre></td></tr></table></figure>

<p><strong>帮助文档的</strong>地址：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline">https://docs.docker.com/engine/reference/commandline</a></p>
<h2 id="3-1-镜像命令"><a href="#3-1-镜像命令" class="headerlink" title="3.1 镜像命令"></a>3.1 <strong>镜像命令</strong></h2><p><strong>docker images</strong>    #查看本地主机上的镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@linyigang ~]# docker images </span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    d1165f221234   2 months ago   13.3kB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释</span></span><br><span class="line">REPOSITORY 	镜像的仓库源</span><br><span class="line">TAG			镜像的标签</span><br><span class="line">IMAGE ID	镜像的ID</span><br><span class="line">CREATED 	创建时间</span><br><span class="line">SIZE		大小</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用可选项</span></span><br><span class="line">  -a, --all             Show all images (default hides intermediate images)</span><br><span class="line">  -q, --quiet           Only show image IDs</span><br></pre></td></tr></table></figure>

<p><strong>docker search</strong> # 搜索镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linyigang ~]# docker search mysql;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选项，仅查出stars大于3000的镜像</span></span><br><span class="line">[root@linyigang ~]# docker search mysql --filter=stars=3000 </span><br></pre></td></tr></table></figure>

<p><strong>docker pull 镜像名 [:tag]</strong>  # 下载镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@linyigang ~]# docker pull mysql</span><br><span class="line">Using default tag: latest # 如果不写tag，默认下载最新的</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">69692152171a: Pull complete 	# 分层下载，docker images的核心，联合文件系统</span><br><span class="line">1651b0be3df3: Pull complete </span><br><span class="line">..........</span><br><span class="line">Digest: sha256:d50098d7fcb25b1fcb24e2d3247cae3fc55815d64fec640dc395840f8fa80969  # 签名</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest 	# 真实地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面等价</span></span><br><span class="line">docker pull mysql</span><br><span class="line">docker pull docker.io/library/mysql:latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">带tag的decker pull</span></span><br><span class="line">[root@linyigang ~]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">69692152171a: Already exists # 联合文件系统，已下载的不需要重新下载</span><br><span class="line">1651b0be3df3: Already exists </span><br><span class="line">..........</span><br><span class="line">a023ae82eef5: Pull complete </span><br><span class="line">e76c35f20ee7: Pull complete </span><br><span class="line">..........</span><br><span class="line">Digest: sha256:a682e3c78fc5bd941e9db080b4796c75f69a28a8cad65677c23f7a9f18ba21fa</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure>

<p><strong>docker rmi</strong>     # 删除镜像，rmi ： remove images</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]  # Usage</span><br><span class="line">docker rmi -f c0cdc95609f1（镜像ID）	# 删除一个镜像	</span><br><span class="line">docker rmi -f 镜像ID1 镜像ID2			# 删除多个镜像</span><br><span class="line">docker rmi -f $(docker images -aq)	   # 删除全部镜像</span><br></pre></td></tr></table></figure>

<p>docker tag # 给镜像改名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag 镜像id 新名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例</span></span><br><span class="line">docker tag f855xxxx linyigang/tomcat:1.0</span><br></pre></td></tr></table></figure>



<h2 id="3-2-容器命令"><a href="#3-2-容器命令" class="headerlink" title="3.2 容器命令"></a>3.2 容器命令</h2><p><strong>说明：有了镜像才可以创建容器</strong></p>
<p>示例：下载一个linux centos进行测试学习</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>

<p><strong>新建容器并启动</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line">--name=&quot;myName&quot; 容器名字，tomcat01 tomcat02，用来区分容器</span><br><span class="line">-d 		后台方式运行</span><br><span class="line">-it		使用交互方式运行，进入容器查看内容</span><br><span class="line">-i      #以交互模式运行容器,通常与-t同时使用，即使没有连接也保持stdin打开</span><br><span class="line">-t      #为容器分配一个伪终端</span><br><span class="line">-p 		指定容器的端口 -p 8080:8080</span><br><span class="line">	-p ip:主机端口：容器端口</span><br><span class="line">	-p 主机端口：容器端口（常用）</span><br><span class="line">	-p 容器端口</span><br><span class="line">-P		随机指定端口</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试，启动并进入容器</span></span><br><span class="line">[root@linyigang ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@38138f4feaf3 /]# ls # 查看容器内的centos，基础版本，很多命令不完善</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@38138f4feaf3 /]# exit</span><br><span class="line">exit</span><br><span class="line">[root@linyigang ~]# cd /</span><br><span class="line">[root@linyigang /]# ls # 和容器的centos相比，可以看到多了一些</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>

<p><strong>列出所有容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker ps		# 所有正在运行的容器</span><br><span class="line">docker ps -a 	# 所有正在运行的容器 + 带出历史运行过的容器</span><br><span class="line">docker ps -n=xx # 显示最近的xx个运行过的容器</span><br><span class="line">docker ps -q 	# 只显示容器的编号</span><br></pre></td></tr></table></figure>

<p><strong>退出容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit	# 直接停止容器并退出</span><br><span class="line">Ctrl + P + Q # 容器不停止，退出</span><br></pre></td></tr></table></figure>

<p><strong>删除容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id  # 不能删除正在运行的容器，需要-f</span><br><span class="line">docker rm -f $(docker ps -aq) # 删除所有容器</span><br><span class="line">docker ps -a -q | xargs docker rm # linux知识</span><br></pre></td></tr></table></figure>

<p><strong>启动和停止容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id		# 启动容器</span><br><span class="line">docker restart 容器id	 	# 重启容器</span><br><span class="line">docker stop	容器id		# 停止当前正在运行的容器</span><br><span class="line">docker kill 容器id  		# 强制停止当前容器</span><br></pre></td></tr></table></figure>

<p><strong>常用的其他命令</strong></p>
<p><strong>后台启动命令</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常见的坑，docker 容器使用后台运行，必须要有一个前台进程，容器发现没有应用，就会自动停止，容器启动后，发现自己没有提供服务，就会立刻停止</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要让后台运行的容器不会退出，可以执行一个不会退出的命令，例如</span></span><br><span class="line">docker run -d centos /bin/sh -c &quot;while true:do echo linyigang;sleep 1;done&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个命令会每隔1s输出一次，由于容器一直有活要干，所以不会退出</span></span><br></pre></td></tr></table></figure>

<p><strong>查看日志</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker logs -tf --tail 10 1921e45dd43f</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数解释</span></span><br><span class="line">-t			# 显示时间戳</span><br><span class="line">-f 			# 跟踪日志输出</span><br><span class="line">--tail n 	# 只输出n条日志</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果容器直接退出就没有任何显示，但是如果是上面每隔1s输出一次的容器，日志就会每隔1s一直输出linyigang</span></span><br></pre></td></tr></table></figure>

<p><strong>查看容器中的进程信息</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器id</span><br></pre></td></tr></table></figure>

<p><strong>查看镜像的元数据</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以看到容器的<span class="built_in">id</span>，创建时间，运行什么命令，命令的参数是什么，pid，镜像等</span></span><br></pre></td></tr></table></figure>

<p><strong>进入当前正在运行的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们通常都是后台运行容器，当需要进入容器执行一些配置时：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令,方式一</span></span><br><span class="line">docker exec -it 容器id /bin/bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式二</span></span><br><span class="line">docker attach 容器id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">exec</span> <span class="comment"># 进入容器后开启一个新的终端，可以在里面操作</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker attach <span class="comment"># 进入容器正在进行的终端，不会开启新的进程</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>从容器内拷贝文件到主机上</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id：容器内路径 目的主机的路径</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现自动同步，比如容器的/home和主机的/home打通</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-实践"><a href="#3-3-实践" class="headerlink" title="3.3 实践"></a>3.3 实践</h2><h3 id="3-3-1-部署Nginx"><a href="#3-3-1-部署Nginx" class="headerlink" title="3.3.1 部署Nginx"></a>3.3.1 部署Nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.搜索镜像，建议直接去docker搜索，可以看到文档和版本</span></span><br><span class="line">docker search nginx --filter=stars=3000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.下载镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.创建容器并启动</span></span><br><span class="line">docker run -d --name nginx01 -p 3344:80 nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.本机访问测试</span></span><br><span class="line">curl localhost:3344</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 3344:80</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-部署tomcat"><a href="#3-3-2-部署tomcat" class="headerlink" title="3.3.2 部署tomcat"></a>3.3.2 部署tomcat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">官方的使用</span></span><br><span class="line">docker run -it --rm tomcat:9.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">之前都是后台启动，停止了容器之后，容器还是可以查到 docker run -it -<span class="built_in">rm</span> 一般用来测试，容器用完即删</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正常使用</span></span><br><span class="line">docker pull tomcat:9.0</span><br><span class="line">docker run -d --name tomcat01 -p 3355:8080 tomcat:9.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试,直接访问，显示404，原因：tomcat镜像中的webapps文件夹里什么都没有，没有页面所以404</span></span><br><span class="line">docker exec -it tomcat01 /bin/bash</span><br><span class="line">cd webapps</span><br><span class="line">ls # 没有输出，空，这是阿里云镜像的原因，默认是最小的镜像，所以不必要的都被剔除，只保证最小可运行环境，其实如果要正常显示tomcat，只需要把webapps同级的webapps.dist中的所有文件拷贝到webapps就可以了</span><br><span class="line"></span><br><span class="line">cp webapps.dist.* webapps</span><br></pre></td></tr></table></figure>

<h2 id="3-4-可视化"><a href="#3-4-可视化" class="headerlink" title="3.4 可视化"></a>3.4 可视化</h2><ul>
<li>portainer（不是最佳选择）</li>
<li>Rancher（CI/CD再用）</li>
</ul>
<p>什么是portainer？</p>
<p>Docker图形化界面工具，提供一个后台面板供我们操作。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:9000 \</span><br><span class="line">--restart=always -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">--privileged=true portainer/portainer</span><br></pre></td></tr></table></figure>

<p>访问测试：<a target="_blank" rel="noopener" href="http://120.79.220.81:8088/">http://120.79.220.81:8088/</a></p>
<p>进入之后，设置账号密码，然后选择local</p>
<img src="D:\Typora\myMarkDown\images\image-20210523151709602.png" alt="image-20210523151709602" style="zoom: 25%;float:left" />



<h1 id="四、Docker-镜像详解"><a href="#四、Docker-镜像详解" class="headerlink" title="四、Docker 镜像详解"></a>四、Docker 镜像详解</h1><h2 id="4-1-什么是镜像"><a href="#4-1-什么是镜像" class="headerlink" title="4.1 什么是镜像"></a>4.1 什么是镜像</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件</p>
<p>所有的应用，直接打包docker镜像，就可以直接跑起来</p>
<p><strong>如何得到镜像：</strong></p>
<ol>
<li>从远程仓库下载</li>
<li>别人拷贝给我</li>
<li>自己制作一个镜像DockerFile</li>
</ol>
<h2 id="4-2-Docker-镜像加载原理"><a href="#4-2-Docker-镜像加载原理" class="headerlink" title="4.2 Docker 镜像加载原理"></a>4.2 Docker 镜像加载原理</h2><p>下载时可以看出，当镜像A的基础是某n层文件，镜像B也需要这n层文件，那么这n层文件是可被多个镜像公用的</p>
<p>UnionFS（联合文件系统）：一种分层、轻量级且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层地叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。UnionFS文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<p><strong>Docker镜像加载原理</strong></p>
<p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统就是UnionFS</p>
<p>bootfs 加载用的，系统加载完就卸载掉，共用的</p>
<p>rootfs  在bootfs之上，包含典型linux种的/dev、/bin、/etc等文件</p>
<p>对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令、工具和程序库就可以，因为底层直接用Host的kernel，自己只需要提供rootfs就可以。由此可见不同的linux发行版，bootfs基本一致，rootfs有差别，所以不同发行版可共用bootfs。vm虚拟机没有共用bootfs，所以每个虚拟机需要引导，运行bootfs，所以开机是分钟级别的</p>
<h2 id="4-3-分层理解"><a href="#4-3-分层理解" class="headerlink" title="4.3 分层理解"></a>4.3 分层理解</h2><p><strong>为什么Docker镜像要采用分层结构</strong></p>
<p>最大的好处就是资源共享，多个镜像从相同的基础镜像构建而来，那么宿主机只需要在磁盘上保留一份Base镜像，同时内存中也只需加载一份Base镜像，就可以为所有容器服务，并且镜像的每一层都可以被共享！</p>
<p>假如基于ubuntu linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，则在基础镜像层之上创建第二个镜像曾，如果继续添加一个安全补丁，就会创建第三个镜像层；该镜像当前已包含3个镜像层</p>
<img src="D:\Typora\myMarkDown\images\image-20210523155014858.png" alt="image-20210523155014858" style="zoom:50%;float:left" />

<img src="D:\Typora\myMarkDown\images\image-20210523160107736.png" alt="image-20210523160107736" style="zoom:25%;float:left" />

<p><strong>特点：</strong><br><strong>Docker镜像都是只读的，当容器启动后，一个新的可写层被加载到镜像的顶部，这一层就是我们通常说的容器层，容器之下都叫镜像层</strong></p>
<h2 id="4-4-commit-镜像"><a href="#4-4-commit-镜像" class="headerlink" title="4.4 commit 镜像"></a>4.4 commit 镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交容器成为一个新的副本</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令和原理和git类似</span></span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名[:TAG]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例3.3.2中，做出了一个webapps有内容的容器，现在将这个容器提交为镜像，以后直接用这个镜像，不用再将webapps.dist里的文件拷贝到webapps了</span></span><br><span class="line">docker commit -m=&quot;add webapps app&quot; -a=&quot;linyigang&quot; a7aadb0a640c tomcat02:1.0</span><br></pre></td></tr></table></figure>



<h1 id="五、容器数据卷"><a href="#五、容器数据卷" class="headerlink" title="五、容器数据卷"></a>五、容器数据卷</h1><h2 id="5-1-什么是容器数据卷"><a href="#5-1-什么是容器数据卷" class="headerlink" title="5.1 什么是容器数据卷"></a>5.1 什么是容器数据卷</h2><p>场景引入：数据不应该放在容器中，如果容器被删除，数据就会丢失。举例：mysql，把容器删了，就是删库跑路！</p>
<p><strong>现有需求：数据可以持久化。</strong></p>
<p>所以现在需要容器之间有一个数据共享的技术！Docker容器中产生的数据，同步到本地！</p>
<p>这就是卷技术，目录的挂载，将我们容器中的目录，挂载到linux上。</p>
<p><strong>总结：卷技术实现了容器的持久化和同步操作，并且让容器间也可以数据共享</strong></p>
<h2 id="5-2-使用数据卷-方式一"><a href="#5-2-使用数据卷-方式一" class="headerlink" title="5.2 使用数据卷 方式一"></a>5.2 使用数据卷 方式一</h2><h3 id="方式一：直接使用命令来挂载-v"><a href="#方式一：直接使用命令来挂载-v" class="headerlink" title="方式一：直接使用命令来挂载 -v"></a>方式一：直接使用命令来挂载 -v</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器内目录 容器id</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line">docker run -it -v /home/test:/home centos /bin/bash # 此时可以看到云服务器已经有/home/test这个目录，然后这两个目录就是双向绑定了</span><br></pre></td></tr></table></figure>

<p>以后修改只需要在本地修改即可，容器内会自动同步</p>
<p>实例：持久化mysql</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取镜像</span> </span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行容器，需要挂载数据</span></span><br><span class="line">docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装启动mysql，需要配置密码！官方测试如下</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker run --name mysql -e MYSQL_ROOT_PASSWORD=mypassword -d mysql:tag</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改后的运行命令</span></span><br><span class="line">docker run -d -p 3310:3306 --name mysql -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=missing0 -d mysql:5.7</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动成功之后用数据库工具测试是否可以连接到服务器的3310端口，连接成功，如下图</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在数据库工具中创建新数据库，可以看到data目录下也有对应变化</span></span><br></pre></td></tr></table></figure>

<img src="D:\Typora\myMarkDown\images\image-20210523185118484.png" alt="image-20210523185118484" style="zoom: 33%;float:left" />

<img src="D:\Typora\myMarkDown\images\image-20210523185611492.png" alt="image-20210523185611492" style="zoom:50%;float:left" />

<h2 id="5-3-具名和匿名挂载"><a href="#5-3-具名和匿名挂载" class="headerlink" title="5.3 具名和匿名挂载"></a>5.3 具名和匿名挂载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匿名挂载</span></span><br><span class="line">-v 容器内路径</span><br><span class="line">docker run -d -P --name nginx02 -v /etc/nginx nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有的卷的情况</span></span><br><span class="line">[root@linyigang /]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     67525b824322acdd2236aef1bfc09b71b5a2b3ca3481192c189ceb86e78c97fb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里发现，这就是匿名挂载，我们在-v只写了容器内的路径，没有写容器外的路径</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具名挂载</span></span><br><span class="line">docker run -d -P --name nginx03 -v juming-nginx:/etc/nginx nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 -v 卷名：容器内路径 实现具名挂载</span></span><br></pre></td></tr></table></figure>

<p>**所有的docker容器内的卷，没有指明目录的情况下都是在<code>/var/lib/docker/volumes/xxxx/_data</code>**，而指明目录的卷就在指定的目录中</p>
<p>通过具名挂载可以方便地找到我们的卷，所以大多数情况使用具名挂载</p>
<h3 id="5-3-2-匿名挂载、具名挂载、指定路径挂载"><a href="#5-3-2-匿名挂载、具名挂载、指定路径挂载" class="headerlink" title="5.3.2 匿名挂载、具名挂载、指定路径挂载"></a>5.3.2 匿名挂载、具名挂载、指定路径挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如何确定是具名挂载还是匿名挂载，还是指定路径挂载</span></span><br><span class="line">-v 容器内路径 			# 匿名挂在</span><br><span class="line">-v 卷名:容器内路径 	   # 剧名挂在</span><br><span class="line">-v /宿主机路径:容器内路径	 # 指定路径挂载</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拓展 通过 -v 容器内路径:ro rw 改变读写权限</span></span><br><span class="line">ro readonly 	# 只读，只能通过宿主机操作，容器内部无法操作</span><br><span class="line">rw readwrite	# 可读写</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一旦设置了容器权限，容器对我们挂载出来的内容就有限定了</span></span><br><span class="line">docker run -d -P --name nginx03 -v juming-nginx:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx03 -v juming-nginx:/etc/nginx:rw nginx</span><br></pre></td></tr></table></figure>

<h2 id="5-4-使用数据卷-方式二-Dockerfile"><a href="#5-4-使用数据卷-方式二-Dockerfile" class="headerlink" title="5.4 使用数据卷 方式二 Dockerfile"></a>5.4 使用数据卷 方式二 Dockerfile</h2><p>Dockerfile就是用来构建docker镜像的构建文件，是一个命令脚本，通过这个脚本可以生成镜像，镜像是一层一层的，脚本一个个的命令，每一个命令都是一层</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">cd /home</span><br><span class="line">mkdir docker-test-volume</span><br><span class="line">cd docker-test-volume</span><br><span class="line">vim dockerfile1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里写脚本</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件中的内容 指令（大写） 参数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start dockerfile1</span></span><br><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]</span><br><span class="line">CMD echo &quot;....end....&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">end dockerfile1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据文件生成镜像</span></span><br><span class="line">docker build -f dockerfile1 -t /linyigang/centos .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行镜像，可以看到dockerfile中挂载的两个目录</span></span><br><span class="line">docker run -it linyigang/centos</span><br><span class="line">[root@linyigang home]# docker run -it linyigang/centos</span><br><span class="line">[root@88cbe0255def /]# ls -l</span><br><span class="line">total 56</span><br><span class="line">lrwxrwxrwx   1 root root    7 Nov  3  2020 bin -&gt; usr/bin</span><br><span class="line">.........</span><br><span class="line">drwxr-xr-x   2 root root 4096 May 23 12:30 volume01</span><br><span class="line">drwxr-xr-x   2 root root 4096 May 23 12:30 volume02</span><br></pre></td></tr></table></figure>

<p>可以看到每次新创建一个容器，都会挂载新的volume1和volume2</p>
<img src="D:\Typora\myMarkDown\images\image-20210523203413961.png" alt="image-20210523203413961" style="zoom:50%;float=left" />

<p><strong>这种在dockerfile中挂载的方式使用很多，因为我们通常会构建自己的镜像；如果构建镜像时没有挂在，就在之后手动具名挂载</strong></p>
<h2 id="5-5-数据卷容器"><a href="#5-5-数据卷容器" class="headerlink" title="5.5 数据卷容器"></a>5.5 数据卷容器</h2><p>多个容器（如mysql）同步数据</p>
<p><strong>–volumes-from docker01</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动3个数据卷</span></span><br><span class="line">docker run -it --name docker01 linyigang/centos</span><br><span class="line">docker run -it --name docker02 --volumes-from docker01 linyigang/centos # 这里把volume与docker01绑定</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后改变docker01或者docker02的volume会引起对方的相应改变(lyg个人认为，本质上还是修改了服务器上的volume)；如果删除docker01，docker02的数据还在，因为最终还是在服务器上有存档</span></span><br></pre></td></tr></table></figure>

<p>实例：多个mysql共用同一个数据库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3310:3306 --name mysql01 -v /etc/mysql/conf.d \</span><br><span class="line">-v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=missing0 -d mysql:5.7</span><br><span class="line"></span><br><span class="line">docker run -d -p 3311:3306 --name mysql02 --volumes-from mysql01 -e MYSQL_ROOT_PASSWORD=missing0 -d mysql:5.7</span><br></pre></td></tr></table></figure>



<h1 id="六、DockerFile"><a href="#六、DockerFile" class="headerlink" title="六、DockerFile"></a>六、DockerFile</h1><p>dockerfile是用来构建docker镜像的文件，是命令参数脚本</p>
<p><strong>构建步骤：</strong></p>
<ol>
<li><strong>编写一个dockerfile 文件</strong></li>
<li><strong>docker build 构建</strong></li>
<li><strong>docker run 运行镜像</strong></li>
<li><strong>docker push 发布镜像（DockerHub、阿里云镜像仓库）</strong></li>
</ol>
<h2 id="6-1-DockerFile基本知识"><a href="#6-1-DockerFile基本知识" class="headerlink" title="6.1 DockerFile基本知识"></a>6.1 DockerFile基本知识</h2><ol>
<li><p>每个保留关键字（指令）都是大写字母</p>
</li>
<li><p>从上到下顺序执行</p>
</li>
<li><p>#表示注释</p>
</li>
<li><p>每一个指令都会创建提交一个新的镜像层，并提交！</p>
<img src="D:\Typora\myMarkDown\images\image-20210523230854806.png" alt="image-20210523230854806" style="zoom:50%;float:left" />

<p>dockerfile是面向开发的，以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件非常简单</p>
<p><strong>docker镜像逐渐成为企业交付的标准，必须要掌握</strong></p>
<p><strong>DockerFile：构建文件，定义了一切的步骤，源代码</strong></p>
<p><strong>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行的产品</strong></p>
<p><strong>Docker容器：容器就是镜像运行起来提供服务器</strong></p>
</li>
</ol>
<h2 id="6-2-DockerFile-基本命令"><a href="#6-2-DockerFile-基本命令" class="headerlink" title="6.2 DockerFile 基本命令"></a>6.2 DockerFile 基本命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM		# 基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER	# 镜像是谁写的，姓名+邮箱</span><br><span class="line">RUN			# 镜像构建的时候需要运行的命令</span><br><span class="line">ADD 		# 步骤，需要用到tomcat时，在这里加入</span><br><span class="line">WORKDIR		# 镜像的工作目录(进入镜像之后默认在哪个目录进行操作)</span><br><span class="line">VOLUME		# 挂载的目录</span><br><span class="line">EXPOSE		# 指定暴露端口，如果没写则需要run镜像的时候用-p指定</span><br><span class="line">CMD			# 指定容器启动的时候要执行的命令，只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT	# 指定容器启动的时候要执行的命令，可以追加命令，只有最后一个ENTRYPOINT生效，并且ENTRYPOINT后的CMD会拼接起来，例如entrypoint 是 ls -a，如果后面CMD [&quot;-l&quot;]，则最终run的时候输出 ls -al的结果</span><br><span class="line">ONBUILD 	# 只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</span><br><span class="line">COPY		# 类似ADD，将我们的文件拷贝到镜像中</span><br><span class="line">ENV			# 构建的时候设置环境变量</span><br></pre></td></tr></table></figure>

<h2 id="6-3-实战1：创建自己的centos"><a href="#6-3-实战1：创建自己的centos" class="headerlink" title="6.3 实战1：创建自己的centos"></a>6.3 实战1：创建自己的centos</h2><p>Docker Hub中99%的镜像都是从这个基础镜像过来的，FROM scratch，然后配置需要的软件和配置来进行构建</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.创建一个自己的centos，前期准备</span></span><br><span class="line">cd /home</span><br><span class="line">mkdir dockerfile</span><br><span class="line">cd dockerfile</span><br><span class="line">vim mydockerfile-centos</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.编写dockerfile的文件：mydockerfile-centos</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">StartFile</span></span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER linyigang&lt;1845955407@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH </span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;...end...&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">EndFile</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.通过这个文件构建镜像</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令 docker build -f dockerfile文件路径 -t 镜像名[:tag]</span> </span><br><span class="line">docker build -f mydockerfile-centos -t mycentos:0.1 .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.测试我们的centos是不是有vim和ifconfig命令</span></span><br><span class="line">docker run -it mycentos:0.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5.可以看到镜像的历史</span></span><br><span class="line">docker history 镜像id</span><br><span class="line">[root@linyigang dockerfile]# docker history aff4e11c9f92</span><br><span class="line">IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT</span><br><span class="line">aff4e11c9f92   8 minutes ago   /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;/bin…   0B        </span><br><span class="line">313c71cc7f54   8 minutes ago   /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo…   0B        </span><br><span class="line">ac81d166aaf9   8 minutes ago   /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo…   0B        </span><br><span class="line">192bd92eaebf   8 minutes ago   /bin/sh -c #(nop)  EXPOSE 80                    0B        </span><br><span class="line">880c137f2851   8 minutes ago   /bin/sh -c yum -y install net-tools             23.3MB    </span><br><span class="line">c1fb16dd4d2f   8 minutes ago   /bin/sh -c yum -y install vim                   58MB      </span><br><span class="line">f61ff646d3a0   8 minutes ago   /bin/sh -c #(nop) WORKDIR /usr/local            0B        </span><br><span class="line">bf50f2ed76b3   8 minutes ago   /bin/sh -c #(nop)  ENV MYPATH=/usr/local        0B        </span><br><span class="line">e926f747bd9b   8 minutes ago   /bin/sh -c #(nop)  MAINTAINER linyigang&lt;1845…   0B        </span><br><span class="line">300e315adb2f   5 months ago    /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span><br><span class="line">&lt;missing&gt;      5 months ago    /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B        </span><br><span class="line">&lt;missing&gt;      5 months ago    /bin/sh -c #(nop) ADD file:bd7a2aed6ede423b7…   209MB   </span><br></pre></td></tr></table></figure>

<h2 id="6-4-CMD和ENTRYPOINT的区别"><a href="#6-4-CMD和ENTRYPOINT的区别" class="headerlink" title="6.4 CMD和ENTRYPOINT的区别"></a>6.4 CMD和ENTRYPOINT的区别</h2><p><strong>测试cmd</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim dockerfile-cmd-test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">File</span></span><br><span class="line">FROM centos</span><br><span class="line">CMD [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">endFile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建镜像</span></span><br><span class="line">docker build -f dockerfile-cmd-test -t cmdtest .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接run</span></span><br><span class="line">docker run cmdtest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果，列出来centos的目录，有多条CMD只运行最后一条</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">想追加一个命令，变为<span class="built_in">ls</span> -al</span></span><br><span class="line">docker run cmdtest -l</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果报错，原因：-l替代了原有的 <span class="built_in">ls</span> -a命令，而-l不是命令，所以报错；正确写法</span></span><br><span class="line">docker run cmdtest ls -al</span><br></pre></td></tr></table></figure>

<p><strong>测试ENTRYPOINT</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim dockerfile-entrypoint-test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">File</span></span><br><span class="line">FROM centos</span><br><span class="line">ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">endFile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建镜像</span></span><br><span class="line">docker build -f dockerfile-entrypoint-test -t entrypointtest .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接run</span></span><br><span class="line">docker run entrypointtest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果同上，列出来centos的目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">想追加一条命令，变为<span class="built_in">ls</span> -al</span></span><br><span class="line">docker run entrypointtest -l # 没有报错，运行ls -al</span><br></pre></td></tr></table></figure>

<h2 id="6-5-实战2：Tomcat镜像"><a href="#6-5-实战2：Tomcat镜像" class="headerlink" title="6.5 实战2：Tomcat镜像"></a>6.5 实战2：Tomcat镜像</h2><ol>
<li><p>准备镜像文件 tomcat压缩包 jdk的压缩包</p>
<img src="D:\Typora\myMarkDown\images\image-20210524112718882.png" alt="image-20210524112718882" style="zoom:50%;float:left" /></li>
<li><p>编写dockerfile，官方命名 <code>Dockerfile</code>，build会自动寻找这个文件，就不需要-f指定了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vim Dockerfile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Dockerfile</span></span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER linyigang&lt;1845955407@qq.com&gt;</span><br><span class="line">COPY readme.txt /usr/local/readme.txt</span><br><span class="line">ADD apache-tomcat-9.0.46.tar.gz /usr/local/</span><br><span class="line">ADD jdk-8u291-linux-x64.tar.gz /usr/local/</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_291</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.46</span><br><span class="line">ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.46</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME</span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD usr/local/apache-tomcat-9.0.46/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.46/bin/logs/catalina.out</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">EndFile</span></span><br></pre></td></tr></table></figure></li>
<li><p>构建镜像，运行镜像，访问测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建</span></span><br><span class="line">docker build -t diytomcat .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行</span></span><br><span class="line">docker run -d -p 9091:8080 --name linyigangtomcat12 -v /home/linyigang/build/tomcat/test:/usr/local/apache-tomcat-9.0.46/webapps/test -v /home/linyigang/build/tomcat/tomcatlogs:/usr/local/apache-tomcat-9.0.46/logs diytomcat</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试</span></span><br><span class="line">docker exec -it 67726b8094ff /bin/bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问http://120.79.220.81:9091/ 可以看到tomcat的欢迎页</span></span><br></pre></td></tr></table></figure></li>
<li><p>发布项目（由于做了卷挂载，可以直接在本地编写项目）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cd test</span><br><span class="line">mkdir WEB_INF</span><br><span class="line">cd WEB_INF</span><br><span class="line">vim web.xml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">web.xml</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</span><br><span class="line">           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">           xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee</span><br><span class="line">                               http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span><br><span class="line">           version=&quot;2.5&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">endFile</span></span><br></pre></td></tr></table></figure>

<p>index.html</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ui&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ui&gt;</span><br><span class="line">&lt;h1&gt;这是标题&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;这是副标题&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;这是段落这是段落这是段落这是段落&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>访问<a target="_blank" rel="noopener" href="http://120.79.220.81:9091/test/">Document</a></p>
<p>可以看到正常页面</p>
</li>
</ol>
<p><strong>我们以后开发的步骤：掌握Dockerfile的编写。以后一切都是使用docker镜像来发布运行</strong></p>
<h2 id="6-6-发布自己的镜像"><a href="#6-6-发布自己的镜像" class="headerlink" title="6.6 发布自己的镜像"></a>6.6 发布自己的镜像</h2><h3 id="6-6-1-DockerHub"><a href="#6-6-1-DockerHub" class="headerlink" title="6.6.1 DockerHub"></a>6.6.1 DockerHub</h3><ol>
<li><p>注册登录DockerHub账号，官网： <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a></p>
</li>
<li><p>在我们的服务器提交自己的镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker login -u linyigang</span><br><span class="line">docker push linyigang/diytomcat:1.0</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6-6-2-阿里云镜像服务"><a href="#6-6-2-阿里云镜像服务" class="headerlink" title="6.6.2 阿里云镜像服务"></a>6.6.2 阿里云镜像服务</h3><ol>
<li><p>登录阿里云</p>
</li>
<li><p>找到容器镜像服务</p>
</li>
<li><p>创建命名空间</p>
</li>
<li><p>创建镜像仓库</p>
</li>
<li><p>浏览镜像仓库中的信息</p>
<img src="D:\Typora\myMarkDown\images\image-20210524153507082.png" alt="image-20210524153507082" style="zoom:50%;float:left" />

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 登录阿里云Docker Registry</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker login --username=lin****ng15 registry.cn-shenzhen.aliyuncs.com</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">您可以在访问凭证页面修改凭证密码。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 从Registry中拉取镜像</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker pull registry.cn-shenzhen.aliyuncs.com/gzhu-linyigang/linyigang-dockerstudy:[镜像版本号]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 将镜像推送到Registry</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker login --username=lin****ng15 registry.cn-shenzhen.aliyuncs.com</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/gzhu-linyigang/linyigang-dockerstudy:[镜像版本号]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker push registry.cn-shenzhen.aliyuncs.com/gzhu-linyigang/linyigang-dockerstudy:[镜像版本号]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 选择合适的镜像仓库地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-shenzhen.aliyuncs.com 作为Registry的域名登录。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5. 示例</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用<span class="string">&quot;docker tag&quot;</span>命令重命名镜像，并将它通过专有网络地址推送至Registry。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker images</span></span><br><span class="line">REPOSITORY                                                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">registry.aliyuncs.com/acs/agent                                    0.7-dfb6816         37bb9c63c8b2        7 days ago          37.89 MB</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker tag 37bb9c63c8b2 registry-vpc.cn-shenzhen.aliyuncs.com/acs/agent:0.7-dfb6816</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 <span class="string">&quot;docker push&quot;</span> 命令将该镜像推送至远程。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker push registry-vpc.cn-shenzhen.aliyuncs.com/acs/agent:0.7-dfb6816</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="6-7-Dockerfile-开发全流程-总结"><a href="#6-7-Dockerfile-开发全流程-总结" class="headerlink" title="6.7 Dockerfile 开发全流程 总结"></a>6.7 Dockerfile 开发全流程 总结</h2><img src="D:\Typora\myMarkDown\images\image-20210524155157138.png" alt="image-20210524155157138" style="zoom:50%;float:left" />



<h1 id="七、Docker-网络"><a href="#七、Docker-网络" class="headerlink" title="七、Docker 网络"></a>七、Docker 网络</h1><p>这一部分是后面Docker Compose等的基础，和运维相关，所以这里先不学</p>
<p>视频p34未看</p>
<p>docker pull mariadb</p>
<p>docker pull adminer</p>
<p>docker pull redis</p>
<p>docker pull ghcr.io/soruly/liresolr:latest</p>
<p>docker pull ghcr.io/soruly/trace.moe-www:latest</p>
<p>docker pull ghcr.io/soruly/trace.moe-api:latest</p>
<p>docker pull ghcr.io/soruly/trace.moe-media:latest</p>
<p>docker pull ghcr.io/soruly/trace.moe-worker-hasher:latest</p>
<p>docker pull ghcr.io/soruly/trace.moe-worker-loader:latest</p>
<p>docker pull ghcr.io/soruly/trace.moe-worker-watcher:latest</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/18/test/" data-id="cl9dvg3k6000170tx9m7o3idj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/10/18/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/18/test/">test</a>
          </li>
        
          <li>
            <a href="/2022/10/18/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>